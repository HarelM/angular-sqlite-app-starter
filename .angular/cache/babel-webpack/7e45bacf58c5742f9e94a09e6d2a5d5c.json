{"ast":null,"code":"import _asyncToGenerator from \"/Users/queaujeanpierre/Development/latest/angular-sqlite-app-starter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Capacitor } from '@capacitor/core';\nimport { CapacitorSQLite, SQLiteConnection } from '@capacitor-community/sqlite';\nimport * as i0 from \"@angular/core\";\nexport let SQLiteService = /*#__PURE__*/(() => {\n  class SQLiteService {\n    constructor() {\n      this.isService = false;\n      this.native = false;\n    }\n    /**\n     * Plugin Initialization\n     */\n\n\n    initializePlugin() {\n      return new Promise(resolve => {\n        this.platform = Capacitor.getPlatform();\n        if (this.platform === 'ios' || this.platform === 'android') this.native = true;\n        this.sqlitePlugin = CapacitorSQLite;\n        this.sqlite = new SQLiteConnection(this.sqlitePlugin);\n        this.isService = true;\n        resolve(true);\n      });\n    }\n    /**\n     * Echo a value\n     * @param value\n     */\n\n\n    echo(value) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this.sqlite != null) {\n          try {\n            const ret = yield _this.sqlite.echo(value);\n            return Promise.resolve(ret);\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(\"no connection open\"));\n        }\n      })();\n    }\n\n    isSecretStored() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this2.native) {\n          return Promise.reject(new Error(`Not implemented for ${_this2.platform} platform`));\n        }\n\n        if (_this2.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this2.sqlite.isSecretStored());\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n\n    setEncryptionSecret(passphrase) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this3.native) {\n          return Promise.reject(new Error(`Not implemented for ${_this3.platform} platform`));\n        }\n\n        if (_this3.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this3.sqlite.setEncryptionSecret(passphrase));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n\n    changeEncryptionSecret(passphrase, oldpassphrase) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this4.native) {\n          return Promise.reject(new Error(`Not implemented for ${_this4.platform} platform`));\n        }\n\n        if (_this4.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this4.sqlite.changeEncryptionSecret(passphrase, oldpassphrase));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * addUpgradeStatement\n     * @param database\n     * @param fromVersion\n     * @param toVersion\n     * @param statement\n     * @param set\n     */\n\n\n    addUpgradeStatement(database, fromVersion, toVersion, statement, set) {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this5.sqlite != null) {\n          try {\n            yield _this5.sqlite.addUpgradeStatement(database, fromVersion, toVersion, statement, set ? set : []);\n            return Promise.resolve();\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open for ${database}`));\n        }\n      })();\n    }\n    /**\n     * get a non-conformed database path\n     * @param path\n     * @param database\n     * @returns Promise<capNCDatabasePathResult>\n     * @since 3.3.3-1\n     */\n\n\n    getNCDatabasePath(folderPath, database) {\n      var _this6 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this6.sqlite != null) {\n          try {\n            const res = yield _this6.sqlite.getNCDatabasePath(folderPath, database);\n            return Promise.resolve(res);\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open for ${database}`));\n        }\n      })();\n    }\n    /**\n     * Create a non-conformed database connection\n     * @param databasePath\n     * @param version\n     * @returns Promise<SQLiteDBConnection>\n     * @since 3.3.3-1\n     */\n\n\n    createNCConnection(databasePath, version) {\n      var _this7 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this7.sqlite != null) {\n          try {\n            const db = yield _this7.sqlite.createNCConnection(databasePath, version);\n\n            if (db != null) {\n              return Promise.resolve(db);\n            } else {\n              return Promise.reject(new Error(`no db returned is null`));\n            }\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open for ${databasePath}`));\n        }\n      })();\n    }\n    /**\n     * Close a non-conformed database connection\n     * @param databasePath\n     * @returns Promise<void>\n     * @since 3.3.3-1\n     */\n\n\n    closeNCConnection(databasePath) {\n      var _this8 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this8.sqlite != null) {\n          try {\n            yield _this8.sqlite.closeNCConnection(databasePath);\n            return Promise.resolve();\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open for ${databasePath}`));\n        }\n      })();\n    }\n    /**\n     * Check if a non-conformed databaseconnection exists\n     * @param databasePath\n     * @returns Promise<capSQLiteResult>\n     * @since 3.3.3-1\n     */\n\n\n    isNCConnection(databasePath) {\n      var _this9 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this9.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this9.sqlite.isNCConnection(databasePath));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Retrieve a non-conformed database connection\n     * @param databasePath\n     * @returns Promise<SQLiteDBConnection>\n     * @since 3.3.3-1\n     */\n\n\n    retrieveNCConnection(databasePath) {\n      var _this10 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this10.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this10.sqlite.retrieveNCConnection(databasePath));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open for ${databasePath}`));\n        }\n      })();\n    }\n    /**\n     * Check if a non conformed database exists\n     * @param databasePath\n     * @returns Promise<capSQLiteResult>\n     * @since 3.3.3-1\n     */\n\n\n    isNCDatabase(databasePath) {\n      var _this11 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this11.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this11.sqlite.isNCDatabase(databasePath));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Create a connection to a database\n     * @param database\n     * @param encrypted\n     * @param mode\n     * @param version\n     */\n\n\n    createConnection(database, encrypted, mode, version) {\n      var _this12 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this12.sqlite != null) {\n          try {\n            const db = yield _this12.sqlite.createConnection(database, encrypted, mode, version);\n\n            if (db != null) {\n              return Promise.resolve(db);\n            } else {\n              return Promise.reject(new Error(`no db returned is null`));\n            }\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open for ${database}`));\n        }\n      })();\n    }\n    /**\n     * Close a connection to a database\n     * @param database\n     */\n\n\n    closeConnection(database) {\n      var _this13 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this13.sqlite != null) {\n          try {\n            yield _this13.sqlite.closeConnection(database);\n            return Promise.resolve();\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open for ${database}`));\n        }\n      })();\n    }\n    /**\n     * Retrieve an existing connection to a database\n     * @param database\n     */\n\n\n    retrieveConnection(database) {\n      var _this14 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this14.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this14.sqlite.retrieveConnection(database));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open for ${database}`));\n        }\n      })();\n    }\n    /**\n     * Retrieve all existing connections\n     */\n\n\n    retrieveAllConnections() {\n      var _this15 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this15.sqlite != null) {\n          try {\n            const myConns = yield _this15.sqlite.retrieveAllConnections();\n            /*                let keys = [...myConns.keys()];\n                            keys.forEach( (value) => {\n                                console.log(\"Connection: \" + value);\n                            });\n            */\n\n            return Promise.resolve(myConns);\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Close all existing connections\n     */\n\n\n    closeAllConnections() {\n      var _this16 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this16.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this16.sqlite.closeAllConnections());\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Check if connection exists\n     * @param database\n     */\n\n\n    isConnection(database) {\n      var _this17 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this17.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this17.sqlite.isConnection(database));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Check Connections Consistency\n     * @returns\n     */\n\n\n    checkConnectionsConsistency() {\n      var _this18 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this18.sqlite != null) {\n          try {\n            const res = yield _this18.sqlite.checkConnectionsConsistency();\n            return Promise.resolve(res);\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Check if database exists\n     * @param database\n     */\n\n\n    isDatabase(database) {\n      var _this19 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this19.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this19.sqlite.isDatabase(database));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Get the list of databases\n     */\n\n\n    getDatabaseList() {\n      var _this20 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this20.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this20.sqlite.getDatabaseList());\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Get Migratable databases List\n     */\n\n\n    getMigratableDbList(folderPath) {\n      var _this21 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this21.native) {\n          return Promise.reject(new Error(`Not implemented for ${_this21.platform} platform`));\n        }\n\n        if (_this21.sqlite != null) {\n          try {\n            if (!folderPath || folderPath.length === 0) {\n              return Promise.reject(new Error(`You must provide a folder path`));\n            }\n\n            return Promise.resolve(yield _this21.sqlite.getMigratableDbList(folderPath));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Add \"SQLite\" suffix to old database's names\n     */\n\n\n    addSQLiteSuffix(folderPath, dbNameList) {\n      var _this22 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this22.native) {\n          return Promise.reject(new Error(`Not implemented for ${_this22.platform} platform`));\n        }\n\n        if (_this22.sqlite != null) {\n          try {\n            const path = folderPath ? folderPath : \"default\";\n            const dbList = dbNameList ? dbNameList : [];\n            return Promise.resolve(yield _this22.sqlite.addSQLiteSuffix(path, dbList));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Delete old databases\n     */\n\n\n    deleteOldDatabases(folderPath, dbNameList) {\n      var _this23 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this23.native) {\n          return Promise.reject(new Error(`Not implemented for ${_this23.platform} platform`));\n        }\n\n        if (_this23.sqlite != null) {\n          try {\n            const path = folderPath ? folderPath : \"default\";\n            const dbList = dbNameList ? dbNameList : [];\n            return Promise.resolve(yield _this23.sqlite.deleteOldDatabases(path, dbList));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Import from a Json Object\n     * @param jsonstring\n     */\n\n\n    importFromJson(jsonstring) {\n      var _this24 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this24.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this24.sqlite.importFromJson(jsonstring));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Is Json Object Valid\n     * @param jsonstring Check the validity of a given Json Object\n     */\n\n\n    isJsonValid(jsonstring) {\n      var _this25 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this25.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this25.sqlite.isJsonValid(jsonstring));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Copy databases from public/assets/databases folder to application databases folder\n     */\n\n\n    copyFromAssets(overwrite) {\n      var _this26 = this;\n\n      return _asyncToGenerator(function* () {\n        const mOverwrite = overwrite != null ? overwrite : true;\n        console.log(`&&&& mOverwrite ${mOverwrite}`);\n\n        if (_this26.sqlite != null) {\n          try {\n            return Promise.resolve(yield _this26.sqlite.copyFromAssets(mOverwrite));\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Initialize the Web store\n     * @param database\n     */\n\n\n    initWebStore() {\n      var _this27 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this27.platform !== 'web') {\n          return Promise.reject(new Error(`not implemented for this platform: ${_this27.platform}`));\n        }\n\n        if (_this27.sqlite != null) {\n          try {\n            yield _this27.sqlite.initWebStore();\n            return Promise.resolve();\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open`));\n        }\n      })();\n    }\n    /**\n     * Save a database to store\n     * @param database\n     */\n\n\n    saveToStore(database) {\n      var _this28 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this28.platform !== 'web') {\n          return Promise.reject(new Error(`not implemented for this platform: ${_this28.platform}`));\n        }\n\n        if (_this28.sqlite != null) {\n          try {\n            yield _this28.sqlite.saveToStore(database);\n            return Promise.resolve();\n          } catch (err) {\n            return Promise.reject(new Error(err));\n          }\n        } else {\n          return Promise.reject(new Error(`no connection open for ${database}`));\n        }\n      })();\n    }\n\n  }\n\n  SQLiteService.ɵfac = function SQLiteService_Factory(t) {\n    return new (t || SQLiteService)();\n  };\n\n  SQLiteService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: SQLiteService,\n    factory: SQLiteService.ɵfac\n  });\n  return SQLiteService;\n})();","map":null,"metadata":{},"sourceType":"module"}