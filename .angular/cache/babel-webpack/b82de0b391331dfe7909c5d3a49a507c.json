{"ast":null,"code":"import _asyncToGenerator from \"/Users/queaujeanpierre/Development/latest/angular-sqlite-app-starter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { createSchema, firstTeachers, partialImport } from '../utils/types-test-utils';\nimport { deleteDatabase } from '../utils/db-utils';\nimport { Dialog } from '@capacitor/dialog';\nimport { Toast } from '@capacitor/toast';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../services/sqlite.service\";\nimport * as i2 from \"../services/detail.service\";\nimport * as i3 from \"@ionic/angular\";\nexport let TestTypesPage = /*#__PURE__*/(() => {\n  class TestTypesPage {\n    constructor(_sqlite, _detailService) {\n      this._sqlite = _sqlite;\n      this._detailService = _detailService;\n      this.detail = false;\n      this.initPlugin = false;\n    }\n\n    ngAfterViewInit() {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        const showAlert = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (message) {\n            yield Dialog.alert({\n              title: 'Error Dialog',\n              message: message\n            });\n          });\n\n          return function showAlert(_x) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n\n        _this.platform = _this._sqlite.platform;\n\n        if (_this.platform !== 'electron') {\n          const showProgessToast = /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (message) {\n              yield Toast.show({\n                text: message,\n                duration: 'short',\n                position: 'top'\n              });\n            });\n\n            return function showProgessToast(_x2) {\n              return _ref2.apply(this, arguments);\n            };\n          }();\n\n          _this.importListener = _this._sqlite.sqlitePlugin.addListener('sqliteImportProgressEvent', info => {\n            showProgessToast(info.progress);\n          });\n          _this.exportListener = _this._sqlite.sqlitePlugin.addListener('sqliteExportProgressEvent', info => {\n            showProgessToast(info.progress);\n          });\n        }\n\n        try {\n          yield _this.runTest();\n          document.querySelector('.sql-allsuccess').classList.remove('display');\n          console.log(\"$$$ runTest was successful\");\n        } catch (err) {\n          document.querySelector('.sql-allfailure').classList.remove('display');\n          console.log(`$$$ runTest failed ${err.message}`);\n          yield showAlert(err.message);\n        }\n      })();\n    }\n\n    ngOnDestroy() {\n      if (this.platform !== 'electron') {\n        this.importListener.remove();\n        this.exportListener.remove();\n      }\n    }\n\n    runTest() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          let result = yield _this2._sqlite.echo(\"Hello World\");\n          var retDict = yield _this2._sqlite.retrieveAllConnections();\n          /*      for (var conn in retDict) {\n                  console.log(`connection: ${conn}`)\n                }\n          */\n          // initialize the connection\n\n          let db;\n\n          if ((yield _this2._sqlite.isConnection(\"testTypes.db\")).result) {\n            db = yield _this2._sqlite.retrieveConnection(\"testTypes.db\");\n          } else db = yield _this2._sqlite.createConnection(\"testTypes.db\", false, \"no-encryption\", 1); // check if the databases exist \n          // and delete it for multiple successive tests\n\n\n          yield deleteDatabase(db); // open db testNew\n\n          yield db.open(); // create tables in db\n\n          let ret = yield db.execute(createSchema, false);\n\n          if (ret.changes.changes < 0) {\n            return Promise.reject(new Error(\"Execute createSchema failed\"));\n          } // create synchronization table \n\n\n          ret = yield db.createSyncTable(); // set the synchronization date\n\n          const syncDate = \"2020-11-25T08:30:25.000Z\";\n          yield db.setSyncDate(syncDate); // add first teachers in db\n\n          ret = yield db.execute(firstTeachers, false);\n\n          if (ret.changes.changes !== 2) {\n            return Promise.reject(new Error(\"Execute 2 teachers failed\"));\n          } // select all teachers in db\n\n\n          ret = yield db.query(\"SELECT * FROM teachers;\");\n\n          if (ret.values.length !== 2 || ret.values[0].name !== \"Brown\" || ret.values[1].name !== \"Dupont\") {\n            return Promise.reject(new Error(\"Query 1 teachers failed\"));\n          } // update age with statement and values              \n\n\n          let sqlcmd = \"UPDATE teachers SET age = ?, office = ? WHERE id = ?;\";\n          let values = [41, \"ABC\", 1];\n          ret = yield db.run(sqlcmd, values, false);\n          values = [23, \"AEF\", 2];\n          ret = yield db.run(sqlcmd, values, false); // select all teachers in db\n\n          ret = yield db.query(\"SELECT * FROM teachers;\"); // select teachers where age > 40 in db\n\n          sqlcmd = \"SELECT name,email,age FROM teachers WHERE age > ?\";\n          ret = yield db.query(sqlcmd, [40]);\n\n          if (ret.values.length !== 1 || ret.values[0].name !== \"Brown\") {\n            return Promise.reject(new Error(\"Query 2 teachers failed\"));\n          } // close the connection\n\n\n          yield _this2._sqlite.closeConnection(\"testTypes.db\"); // partial import\n\n          result = yield _this2._sqlite.importFromJson(JSON.stringify(partialImport));\n          if (result.changes.changes === -1) return Promise.reject(new Error(\"ImportFromJson 'partial' partialImport1 failed\")); // create the connection to the database\n\n          db = yield _this2._sqlite.createConnection(\"testTypes.db\", false, \"no-encryption\", 1);\n          if (db === null) return Promise.reject(new Error(\"CreateConnection 'testTypes.db' after 'partial' failed\")); // open db \"testTypes\"\n\n          yield db.open(); // select teachers with \"office\" is null\n\n          sqlcmd = \"SELECT * FROM teachers where office IS NULL;\";\n          result = yield db.query(sqlcmd);\n\n          if (result.values.length !== 1 || result.values[0].name !== \"MacLaren\") {\n            return Promise.reject(new Error(\"Query 3 Teachers failed\"));\n          } // export full json\n\n\n          let jsonObj = yield db.exportToJson('full'); // test Json object validity\n\n          result = yield _this2._sqlite.isJsonValid(JSON.stringify(jsonObj.export));\n\n          if (!result.result) {\n            return Promise.reject(new Error(\"IsJsonValid export 'full' failed\"));\n          }\n\n          if (jsonObj.export.database != \"testTypes\" || jsonObj.export.version != 1 || jsonObj.export.mode != \"full\" || jsonObj.export.tables.length != 2) {\n            return Promise.reject(new Error(\"Export Json failed\"));\n          } // Import exported json object\n\n\n          jsonObj.export.database = \"testTypesImported\";\n          result = yield _this2._sqlite.importFromJson(JSON.stringify(jsonObj.export));\n          if (result.changes.changes === -1) return Promise.reject(new Error(\"ImportFromJson 'full' failed\")); // create the connection to the database\n\n          db = yield _this2._sqlite.createConnection(\"testTypesImported\", false, \"no-encryption\", 1);\n          if (db === null) return Promise.reject(new Error(\"CreateConnection 'testTypesImported' after 'full' failed\")); // open db \"testTypesImported\"\n\n          yield db.open(); // select all teachers in db\n\n          ret = yield db.query(\"SELECT * FROM teachers;\");\n\n          if (ret.values.length !== 5 || ret.values[0].name !== \"Brown\" || ret.values[1].name !== \"Dupont\" || ret.values[2].name !== \"MacLaren\" || ret.values[3].name !== \"Bannister\" || ret.values[4].name !== \"Jones\") {\n            return Promise.reject(new Error(\"Query 4 teachers failed\"));\n          } // select all classess in db\n\n\n          ret = yield db.query(\"SELECT * FROM classes;\");\n\n          if (ret.values.length !== 3 || ret.values[0].courseCode !== 1 || ret.values[0].dayOfWeek != \"Monday\" || ret.values[1].courseCode !== 2 || ret.values[1].dayOfWeek != \"Wednesday\" || ret.values[2].courseCode !== 1 || ret.values[2].dayOfWeek != \"Friday\") {\n            return Promise.reject(new Error(\"Query 5 classes failed\"));\n          } // Check Connections Consistency\n\n\n          ret = yield _this2._sqlite.checkConnectionsConsistency();\n\n          if (!ret.result) {\n            return Promise.reject(new Error(\"You must redefined your connections\"));\n          }\n\n          result = yield _this2._sqlite.isConnection(\"testTypes\");\n\n          if (result.result) {\n            // close the connection testTypes\n            yield _this2._sqlite.closeConnection(\"testTypes\");\n          }\n\n          result = yield _this2._sqlite.isConnection(\"testTypesImported\");\n\n          if (result.result) {\n            // close the connection testTypesImported\n            yield _this2._sqlite.closeConnection(\"testTypesImported\");\n          }\n\n          return Promise.resolve();\n        } catch (err) {\n          return Promise.reject(err);\n        }\n      })();\n    }\n\n  }\n\n  TestTypesPage.ɵfac = function TestTypesPage_Factory(t) {\n    return new (t || TestTypesPage)(i0.ɵɵdirectiveInject(i1.SQLiteService), i0.ɵɵdirectiveInject(i2.DetailService));\n  };\n\n  TestTypesPage.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: TestTypesPage,\n    selectors: [[\"app-testtypes\"]],\n    decls: 19,\n    vars: 2,\n    consts: [[3, \"translucent\"], [\"slot\", \"start\"], [\"defaultHref\", \"/\"], [3, \"fullscreen\"], [\"collapse\", \"condense\"], [\"size\", \"large\"], [\"id\", \"container\"], [1, \"card-sqlite\"], [1, \"sql-allsuccess\", \"display\"], [1, \"sql-allfailure\", \"display\"]],\n    template: function TestTypesPage_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ion-header\", 0);\n        i0.ɵɵelementStart(1, \"ion-toolbar\");\n        i0.ɵɵelementStart(2, \"ion-buttons\", 1);\n        i0.ɵɵelement(3, \"ion-back-button\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"ion-title\");\n        i0.ɵɵtext(5, \" TestTypes \");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"ion-content\", 3);\n        i0.ɵɵelementStart(7, \"ion-header\", 4);\n        i0.ɵɵelementStart(8, \"ion-toolbar\");\n        i0.ɵɵelementStart(9, \"ion-title\", 5);\n        i0.ɵɵtext(10, \"TestTypes\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(11, \"div\", 6);\n        i0.ɵɵelementStart(12, \"ion-card\", 7);\n        i0.ɵɵelementStart(13, \"ion-card-title\");\n        i0.ɵɵtext(14, \" Results of refactor sqlite test \");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(15, \"p\", 8);\n        i0.ɵɵtext(16, \" The set of tests was successful \");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(17, \"p\", 9);\n        i0.ɵɵtext(18, \" The set of tests failed \");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"translucent\", true);\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"fullscreen\", true);\n      }\n    },\n    directives: [i3.IonHeader, i3.IonToolbar, i3.IonButtons, i3.IonBackButton, i3.IonBackButtonDelegate, i3.IonTitle, i3.IonContent, i3.IonCard, i3.IonCardTitle],\n    styles: [\"#container[_ngcontent-%COMP%]{text-align:center;position:relative;left:0;right:0;top:5%}#container[_ngcontent-%COMP%]   strong[_ngcontent-%COMP%]{font-size:20px;line-height:26px}.display[_ngcontent-%COMP%]{display:none}.card-sqlite[_ngcontent-%COMP%]{padding:0 1rem}ion-card[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-size:1rem}ion-card[_ngcontent-%COMP%]{--background: var(--ion-background-color);--color: var(--ion-text-color)}\"]\n  });\n  return TestTypesPage;\n})();","map":null,"metadata":{},"sourceType":"module"}