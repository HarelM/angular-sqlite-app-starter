{"ast":null,"code":"import _asyncToGenerator from \"/Users/queaujeanpierre/Development/latest/angular-sqlite-app-starter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n//import { Capacitor } from '@capacitor/core';\n\n/**\n * SQLiteConnection Class\n */\nexport class SQLiteConnection {\n  constructor(sqlite) {\n    this.sqlite = sqlite;\n    this._connectionDict = new Map();\n  }\n\n  initWebStore() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this.sqlite.initWebStore();\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  saveToStore(database) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this2.sqlite.saveToStore({\n          database\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  echo(value) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this3.sqlite.echo({\n          value\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isSecretStored() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this4.sqlite.isSecretStored();\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  setEncryptionSecret(passphrase) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this5.sqlite.setEncryptionSecret({\n          passphrase: passphrase\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  changeEncryptionSecret(passphrase, oldpassphrase) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this6.sqlite.changeEncryptionSecret({\n          passphrase: passphrase,\n          oldpassphrase: oldpassphrase\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  addUpgradeStatement(database, fromVersion, toVersion, statement, set) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const upgrade = {\n        fromVersion,\n        toVersion,\n        statement,\n        set: set ? set : []\n      };\n\n      try {\n        if (database.endsWith('.db')) database = database.slice(0, -3);\n        yield _this7.sqlite.addUpgradeStatement({\n          database,\n          upgrade: [upgrade]\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  createConnection(database, encrypted, mode, version) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        if (database.endsWith('.db')) database = database.slice(0, -3);\n        yield _this8.sqlite.createConnection({\n          database,\n          encrypted,\n          mode,\n          version\n        });\n        const conn = new SQLiteDBConnection(database, _this8.sqlite);\n\n        _this8._connectionDict.set(database, conn);\n\n        return Promise.resolve(conn);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  closeConnection(database) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        if (database.endsWith('.db')) database = database.slice(0, -3);\n        yield _this9.sqlite.closeConnection({\n          database\n        });\n\n        _this9._connectionDict.delete(database);\n\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isConnection(database) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const res = {};\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n      res.result = _this10._connectionDict.has(database);\n      return Promise.resolve(res);\n    })();\n  }\n\n  retrieveConnection(database) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n\n      if (_this11._connectionDict.has(database)) {\n        const conn = _this11._connectionDict.get(database);\n\n        if (typeof conn != 'undefined') return Promise.resolve(conn);else {\n          return Promise.reject(`Connection ${database} is undefined`);\n        }\n      } else {\n        return Promise.reject(`Connection ${database} does not exist`);\n      }\n    })();\n  }\n\n  getNCDatabasePath(path, database) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const databasePath = yield _this12.sqlite.getNCDatabasePath({\n          path,\n          database\n        });\n        return Promise.resolve(databasePath);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  createNCConnection(databasePath, version) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this13.sqlite.createNCConnection({\n          databasePath,\n          version\n        });\n        const conn = new SQLiteDBConnection(databasePath, _this13.sqlite);\n\n        _this13._connectionDict.set(databasePath, conn);\n\n        return Promise.resolve(conn);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  closeNCConnection(databasePath) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this14.sqlite.closeNCConnection({\n          databasePath\n        });\n\n        _this14._connectionDict.delete(databasePath);\n\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isNCConnection(databasePath) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      const res = {};\n      res.result = _this15._connectionDict.has(databasePath);\n      return Promise.resolve(res);\n    })();\n  }\n\n  retrieveNCConnection(databasePath) {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this16._connectionDict.has(databasePath)) {\n        const conn = _this16._connectionDict.get(databasePath);\n\n        if (typeof conn != 'undefined') return Promise.resolve(conn);else {\n          return Promise.reject(`Connection ${databasePath} is undefined`);\n        }\n      } else {\n        return Promise.reject(`Connection ${databasePath} does not exist`);\n      }\n    })();\n  }\n\n  isNCDatabase(databasePath) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this17.sqlite.isNCDatabase({\n          databasePath\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  retrieveAllConnections() {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this18._connectionDict;\n    })();\n  }\n\n  closeAllConnections() {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      const delDict = new Map();\n\n      try {\n        for (const database of _this19._connectionDict.keys()) {\n          yield _this19.sqlite.closeConnection({\n            database\n          });\n          delDict.set(database, null);\n        }\n\n        for (const database of delDict.keys()) {\n          _this19._connectionDict.delete(database);\n        }\n\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  checkConnectionsConsistency() {\n    var _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const keys = [..._this20._connectionDict.keys()];\n        const res = yield _this20.sqlite.checkConnectionsConsistency({\n          dbNames: keys\n        });\n        if (!res.result) _this20._connectionDict = new Map();\n        return Promise.resolve(res);\n      } catch (err) {\n        _this20._connectionDict = new Map();\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  importFromJson(jsonstring) {\n    var _this21 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const ret = yield _this21.sqlite.importFromJson({\n          jsonstring: jsonstring\n        });\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isJsonValid(jsonstring) {\n    var _this22 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const ret = yield _this22.sqlite.isJsonValid({\n          jsonstring: jsonstring\n        });\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  copyFromAssets(overwrite) {\n    var _this23 = this;\n\n    return _asyncToGenerator(function* () {\n      const mOverwrite = overwrite != null ? overwrite : true;\n\n      try {\n        yield _this23.sqlite.copyFromAssets({\n          overwrite: mOverwrite\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isDatabase(database) {\n    var _this24 = this;\n\n    return _asyncToGenerator(function* () {\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n\n      try {\n        const res = yield _this24.sqlite.isDatabase({\n          database: database\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  getDatabaseList() {\n    var _this25 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this25.sqlite.getDatabaseList();\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  getMigratableDbList(folderPath) {\n    var _this26 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!folderPath || folderPath.length === 0) {\n        return Promise.reject('You must provide a folder path');\n      }\n\n      try {\n        const res = yield _this26.sqlite.getMigratableDbList({\n          folderPath: folderPath\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  addSQLiteSuffix(folderPath, dbNameList) {\n    var _this27 = this;\n\n    return _asyncToGenerator(function* () {\n      const path = folderPath ? folderPath : 'default';\n      const dbList = dbNameList ? dbNameList : [];\n\n      try {\n        const res = yield _this27.sqlite.addSQLiteSuffix({\n          folderPath: path,\n          dbNameList: dbList\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  deleteOldDatabases(folderPath, dbNameList) {\n    var _this28 = this;\n\n    return _asyncToGenerator(function* () {\n      const path = folderPath ? folderPath : 'default';\n      const dbList = dbNameList ? dbNameList : [];\n\n      try {\n        const res = yield _this28.sqlite.deleteOldDatabases({\n          folderPath: path,\n          dbNameList: dbList\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n}\n/**\n * SQLiteDBConnection Class\n */\n\nexport class SQLiteDBConnection {\n  constructor(dbName, sqlite) {\n    this.dbName = dbName;\n    this.sqlite = sqlite;\n  }\n\n  getConnectionDBName() {\n    return this.dbName;\n  }\n\n  open() {\n    var _this29 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this29.sqlite.open({\n          database: _this29.dbName\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  close() {\n    var _this30 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this30.sqlite.close({\n          database: _this30.dbName\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  getVersion() {\n    var _this31 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const version = yield _this31.sqlite.getVersion({\n          database: _this31.dbName\n        });\n        return Promise.resolve(version);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  execute(statements, transaction = true) {\n    var _this32 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this32.sqlite.execute({\n          database: _this32.dbName,\n          statements: statements,\n          transaction: transaction\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  query(statement, values) {\n    var _this33 = this;\n\n    return _asyncToGenerator(function* () {\n      let res;\n\n      try {\n        if (values && values.length > 0) {\n          res = yield _this33.sqlite.query({\n            database: _this33.dbName,\n            statement: statement,\n            values: values\n          });\n        } else {\n          res = yield _this33.sqlite.query({\n            database: _this33.dbName,\n            statement: statement,\n            values: []\n          });\n        }\n\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  run(statement, values, transaction = true) {\n    var _this34 = this;\n\n    return _asyncToGenerator(function* () {\n      let res;\n\n      try {\n        if (values && values.length > 0) {\n          res = yield _this34.sqlite.run({\n            database: _this34.dbName,\n            statement: statement,\n            values: values,\n            transaction: transaction\n          }); //        }\n        } else {\n          res = yield _this34.sqlite.run({\n            database: _this34.dbName,\n            statement: statement,\n            values: [],\n            transaction: transaction\n          });\n        }\n\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  executeSet(set, transaction = true) {\n    var _this35 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this35.sqlite.executeSet({\n          database: _this35.dbName,\n          set: set,\n          transaction: transaction\n        }); //      }\n\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isExists() {\n    var _this36 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this36.sqlite.isDBExists({\n          database: _this36.dbName\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isTable(table) {\n    var _this37 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this37.sqlite.isTableExists({\n          database: _this37.dbName,\n          table: table\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  isDBOpen() {\n    var _this38 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this38.sqlite.isDBOpen({\n          database: _this38.dbName\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  delete() {\n    var _this39 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this39.sqlite.deleteDatabase({\n          database: _this39.dbName\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  createSyncTable() {\n    var _this40 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this40.sqlite.createSyncTable({\n          database: _this40.dbName\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  setSyncDate(syncdate) {\n    var _this41 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this41.sqlite.setSyncDate({\n          database: _this41.dbName,\n          syncdate: syncdate\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  getSyncDate() {\n    var _this42 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this42.sqlite.getSyncDate({\n          database: _this42.dbName\n        });\n        let retDate = '';\n        if (res.syncDate > 0) retDate = new Date(res.syncDate * 1000).toISOString();\n        return Promise.resolve(retDate);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  exportToJson(mode) {\n    var _this43 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this43.sqlite.exportToJson({\n          database: _this43.dbName,\n          jsonexportmode: mode\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n} //# sourceMappingURL=definitions.js.map","map":null,"metadata":{},"sourceType":"module"}